---
layout: default
nav_order: 1
title: UI UX 1
description: "User Interface / User Experience 1"
parent: UI UX
grand_parent: Goorm
has_children: false
permalink: /docs/Bootcamp/Goorm/UI UX/UI UX 1/
---

# 제 1 강 - 디자인의 본질

## 사전 질문
1. 좋은 디자인은 무엇일까요? 이런 디자인을 구현해 내기 위해서 어떤 것들을 고려해야 할까요?
    - 디자인 자체가 기능인 디자인
    - 직관(본능)적으로 어떻게 해야할 지 알게되는 디자인
    - 접근성 측면에서 도움이 되는 디자인
2. 사용자에게 이 제품을 사용하는 방법을 이해시키기 위해서는 어떤 점들을 고려해 설계해야 할까요?
    - 이해보다 인지가 쉽게 만들어 주는것
    - 패턴화 되어있는 생활습관을 사용하게 하는것
    - 온보딩 설명

---

## 디자인의 본질

### 디자인이란 무엇인가?

디자인은 단순히 "예쁘게 만드는 것"이 아닙니다. 디자인의 본질은 **문제 해결**입니다.

> "Design is not just what it looks like and feels like. Design is how it works."  
> — Steve Jobs

#### 핵심 개념
- **기능성 (Functionality)**: 디자인은 목적을 가지고 있으며, 그 목적을 달성해야 합니다
- **사용성 (Usability)**: 사용자가 쉽고 편하게 사용할 수 있어야 합니다
- **심미성 (Aesthetics)**: 시각적으로 매력적이어야 합니다
- **접근성 (Accessibility)**: 모든 사용자가 접근하고 사용할 수 있어야 합니다

---

### 좋은 디자인의 6가지 근본 원리 (Don Norman)

디자인 사상가 Don Norman이 제시한 좋은 디자인의 핵심 원리입니다. 이 원리들은 사용자가 제품을 **쉽게 이해하고, 효과적으로 사용하며, 실수를 최소화**할 수 있도록 돕습니다.

#### 📋 6가지 원리 한눈에 보기

| 원리 | 영문 | 핵심 질문 | 목적 |
|------|------|-----------|------|
| 가시성 | Visibility | "무엇을 할 수 있지?" | 기능 발견 용이성 |
| 피드백 | Feedback | "무슨 일이 일어났지?" | 상태 확인 |
| 제약 | Constraints | "왜 이게 안 되지?" | 오류 방지 |
| 매핑 | Mapping | "이게 어떻게 작동하지?" | 직관적 조작 |
| 일관성 | Consistency | "항상 이렇게 작동하나?" | 학습 전이 |
| 행동 유도성 | Affordance | "이걸 어떻게 써?" | 사용법 암시 |

---

#### 1. **가시성 (Visibility)** 👁️

**정의**: 사용자가 필요한 정보와 기능을 쉽게 발견하고 볼 수 있어야 합니다.

**핵심 원칙**:
- "보이지 않으면 존재하지 않는 것과 같다"
- 중요한 기능일수록 더 눈에 띄어야 함
- 현재 시스템 상태를 명확히 보여주기

**좋은 예 ✅**:
```
1. 엘리베이터
   - 층수 버튼이 숫자 순서대로 명확히 표시
   - 현재 층수와 방향을 화살표로 표시
   - 선택된 층은 불이 들어옴

2. 자동차 계기판
   - 속도, 연료, 경고등이 운전자 시야에 배치
   - 중요한 경고는 빨간색으로 강조

3. 이커머스 장바구니
   - 우측 상단에 장바구니 아이콘과 개수 표시
   - 결제 버튼이 눈에 띄는 색상과 크기
```

**나쁜 예 ❌**:
```
1. 숨겨진 햄버거 메뉴
   - 주요 기능이 3줄 아이콘 뒤에 숨겨짐
   - 사용자가 기능의 존재를 모를 수 있음

2. 제스처 기반 네비게이션
   - 보이지 않는 스와이프 동작
   - 발견하기 어려움

3. 툴팁에만 설명
   - 마우스를 올려야만 보이는 정보
   - 모바일에서는 사용 불가
```

**실무 적용**:
```scss
위치 (Position):
- 주요 기능: 메인 화면 중앙 또는 상단
- 보조 기능: 사이드바, 하단
- 자주 쓰는 기능: 1~2클릭 거리

크기 (Size):
- 중요도에 따라 크기 차별화
- 터치 타겟: 최소 44x44px (Apple) / 48x48px (Google)

색상 (Color):
- 주요 버튼: 브랜드 컬러 (High Contrast)
- 보조 버튼: 중성 컬러
- 경고/오류: 빨간색

시각적 계층 (Visual Hierarchy):
1차: 가장 중요 (큰 크기, 강한 색상)
2차: 보조 정보 (중간 크기)
3차: 부가 정보 (작은 크기, 연한 색상)
```

**측정 지표**:
- Task Success Rate: 사용자가 기능을 찾아서 완료하는 비율
- Time to First Click: 첫 클릭까지 걸리는 시간
- Discovery Rate: 기능 발견율

#### 2. **피드백 (Feedback)** 💬

**정의**: 시스템이 사용자의 행동에 대해 즉각적이고 명확한 반응을 제공해야 합니다.

**핵심 원칙**:
- "내가 한 행동이 받아들여졌는가?"
- 피드백은 즉각적이어야 함 (100ms 이내 반응)
- 적절한 피드백 강도 (너무 약하거나 강하지 않게)

**피드백의 종류**:

**1. 시각적 피드백 (Visual)**
```
- 버튼 클릭: 색상 변화, 눌림 효과
- 로딩: 스피너, 프로그레스 바, 스켈레톤 UI
- 성공: 체크 마크, 초록색 배경
- 실패: X 마크, 빨간색 배경
- 포커스: 테두리 강조, 그림자
```

**2. 청각적 피드백 (Auditory)**
```
- 알림: "띵" 소리
- 오류: 경고음
- 성공: 긍정적인 효과음
- 타이핑: 키보드 클릭음 (선택사항)
```

**3. 촉각적 피드백 (Haptic)**
```
- 버튼 클릭: 진동
- 스크롤 끝: 바운스 효과
- 중요 알림: 강한 진동
```

**좋은 예 ✅**:
```
1. iPhone 키보드
   - 키 입력 시 시각적 강조
   - 햅틱 피드백 (선택 가능)
   - 자동 완성 제안

2. 파일 업로드
   - 프로그레스 바 (0% → 100%)
   - 완료 시 "업로드 완료" 메시지
   - 실패 시 재시도 옵션 제공

3. 좋아요 버튼
   - 클릭 즉시 색상 변경
   - 하트 애니메이션 효과
   - 숫자 카운트 업데이트
```

**나쁜 예 ❌**:
```
1. 반응 없는 버튼
   - 클릭 후 아무 변화 없음
   - 사용자가 여러 번 클릭 (중복 요청)

2. 로딩 표시 없음
   - "지금 처리 중인가?"
   - 사용자가 멈춤인지 로딩인지 구분 불가

3. 모호한 오류 메시지
   - "오류가 발생했습니다"
   - 무엇이 잘못됐는지, 어떻게 해결할지 불명확
```

**실무 적용**:
```scss
타이밍 (Timing):
- 즉각 반응: < 100ms (버튼 클릭)
- 빠른 피드백: < 1초 (간단한 작업)
- 진행 표시: 1~10초 (프로그레스 바)
- 백그라운드: > 10초 (알림으로 완료 통보)

피드백 강도:
Level 1 - 미세한 변화: 색상 톤 변화
Level 2 - 명확한 변화: 색상 완전 변경
Level 3 - 강조된 변화: 애니메이션 추가
Level 4 - 강력한 알림: 모달, 사운드

상태별 피드백:
✓ 성공: 초록색, 체크 아이콘, "완료!"
⚠ 경고: 노란색, 느낌표, "주의 필요"
✗ 오류: 빨간색, X 아이콘, "실패" + 원인 설명
⏳ 진행: 파란색, 스피너, "처리 중..."
```

**피드백 작성 가이드**:
```
좋은 오류 메시지:
❌ "오류가 발생했습니다"
✅ "비밀번호는 8자 이상이어야 합니다"

좋은 성공 메시지:
❌ "완료"
✅ "프로필이 성공적으로 업데이트되었습니다"

좋은 로딩 메시지:
❌ "로딩 중..."
✅ "데이터를 불러오는 중입니다 (약 5초 소요)"
```

#### 3. **제약 (Constraints)** 🚧

**정의**: 사용자가 실수할 수 있는 가능성을 사전에 차단하거나 줄입니다.

**핵심 원칙**:
- "방지는 치료보다 낫다" (Prevention is better than cure)
- 오류가 발생하기 전에 막기
- 불가능한 행동은 아예 시도할 수 없게 만들기

**제약의 4가지 유형**:

**1. 물리적 제약 (Physical Constraints)**
```
하드웨어/물리적 구조로 잘못된 사용 방지

예시:
✅ USB-A: 한 방향으로만 삽입 가능
✅ USB-C: 양방향 모두 가능 (더 개선)
✅ SIM 카드: 한 모서리가 잘려 있어 방향 제한
✅ 자동차 시동: 브레이크를 밟아야 시동 가능
✅ 세탁기: 문이 닫혀야 작동
```

**2. 논리적 제약 (Logical Constraints)**
```
규칙과 로직으로 오류 방지

예시:
✅ 필수 입력란이 비어있으면 제출 버튼 비활성화
✅ 이메일 형식이 맞지 않으면 에러 표시
✅ 재고가 없으면 구매 버튼 회색 처리
✅ 과거 날짜는 선택 불가
✅ 최대 업로드 용량 제한 (10MB)
```

**3. 의미적 제약 (Semantic Constraints)**
```
의미와 맥락에 기반한 제약

예시:
✅ "삭제" 버튼은 빨간색 (위험 암시)
✅ "확인" 버튼은 초록색 (안전 암시)
✅ 전원 버튼은 원형 (⏻)
✅ 재생 버튼은 삼각형 (▶)
```

**4. 문화적 제약 (Cultural Constraints)**
```
문화적 관습과 학습된 규칙

예시:
✅ 빨간 신호등 = 멈춤
✅ 체크박스 = 선택/해제
✅ 휴지통 = 삭제
✅ 돋보기 = 검색
✅ ⚙️ = 설정
```

**좋은 예 ✅**:
```
1. 비밀번호 입력
   - 최소 8자, 대문자/소문자/숫자/특수문자 요구
   - 실시간 검증 및 피드백
   - 요구사항 체크리스트 표시

2. 날짜 선택기
   - 달력 UI로 잘못된 날짜 입력 방지
   - 과거/미래 날짜 제한 옵션
   - 공휴일 자동 표시

3. 중요한 작업 전 확인
   - "정말 삭제하시겠습니까?"
   - 실행 취소 불가능한 작업은 2단계 확인
   - 입력 재확인 (이메일, 비밀번호)

4. 파일 드래그 앤 드롭
   - 허용된 파일 형식만 업로드 가능
   - 드롭 영역 시각적 강조
   - 잘못된 형식은 거부 메시지
```

**나쁜 예 ❌**:
```
1. 제약 없는 입력란
   - 전화번호에 문자 입력 가능
   - 이메일 형식 검증 없음
   - 제출 후에야 오류 발견

2. 되돌릴 수 없는 삭제
   - 확인 없이 바로 삭제
   - 복구 불가능
   - 사용자 후회

3. 모호한 버튼
   - "확인"과 "취소"가 같은 스타일
   - 위험한 행동이 강조되지 않음
```

**실무 적용**:
```scss
입력 검증 (Input Validation):
- 실시간 검증: 입력하는 동안 즉시 피드백
- 형식 제한: type="email", type="number"
- 길이 제한: maxlength, minlength
- 패턴 매칭: 정규표현식으로 검증
- 자동 포맷팅: 전화번호 (010-1234-5678)

버튼 상태:
- 비활성화 (Disabled): 회색, 클릭 불가
- 로딩 (Loading): 스피너, 중복 클릭 방지
- 숨김 (Hidden): 해당 상황에서 불필요하면 숨기기

확인 단계 (Confirmation):
Level 1: 되돌릴 수 있음 → 확인 불필요
Level 2: 중요하지만 되돌릴 수 있음 → 간단한 확인
Level 3: 중요하고 되돌리기 어려움 → 명확한 확인 다이얼로그
Level 4: 매우 중요하고 불가역적 → 2단계 확인 + 재입력

드롭다운 제한:
- 유효한 옵션만 제공
- 검색 가능한 드롭다운
- 기본값 설정으로 유도
```

**제약 vs 유연성의 균형**:
```
❌ 너무 많은 제약
→ 사용자가 답답함을 느낌
→ 특수한 상황 대응 불가

✅ 적절한 제약
→ 일반적인 오류 방지
→ 고급 옵션으로 예외 처리

예시:
기본: 엄격한 제약으로 오류 방지
고급 모드: 전문가를 위한 유연성 제공
```

#### 4. **매핑 (Mapping)** 🗺️

**정의**: 컨트롤(조작)과 그 결과 사이의 관계가 직관적이고 자연스러워야 합니다.

**핵심 원칙**:
- "어디를 누르면 무엇이 움직이는가?"
- 물리적 배치와 기능이 일치
- 자연스러운 인과 관계

**매핑의 3가지 유형**:

**1. 공간적 매핑 (Spatial Mapping)**
```
컨트롤의 위치와 결과의 위치가 일치

좋은 예 ✅:
- 가스레인지: 버튼 배치 = 불판 배치
  [1][2]     [불판1][불판2]
  [3][4]     [불판3][불판4]

- 자동차 사이드미러 조절
  조이스틱을 왼쪽으로 → 미러가 왼쪽으로
  조이스틱을 위로 → 미러가 위로

- 윈도우 창 배치
  창을 화면 왼쪽으로 드래그 → 왼쪽 반 화면 차지

나쁜 예 ❌:
- 가스레인지: 4개 버튼이 일렬 배치
  [1][2][3][4] → 어느 불판인지 헷갈림
```

**2. 기능적 매핑 (Functional Mapping)**
```
컨트롤과 기능 사이의 논리적 관계

좋은 예 ✅:
- 볼륨 슬라이더
  오른쪽으로 → 소리 증가 (더 많음)
  왼쪽으로 → 소리 감소 (더 적음)

- 확대/축소
  + 버튼 → 확대 (더 크게)
  - 버튼 → 축소 (더 작게)

- 스크롤
  휠을 아래로 → 페이지가 아래로 이동
  (또는 콘텐츠가 위로 올라감)

나쁜 예 ❌:
- 비직관적인 방향
  위로 밀면 볼륨 감소 (예상: 증가)
  아래로 밀면 볼륨 증가 (예상: 감소)
```

**3. 자연스러운 매핑 (Natural Mapping)**
```
현실 세계의 경험과 일치

좋은 예 ✅:
- 스티어링 휠
  오른쪽으로 돌리면 → 차가 오른쪽으로
  왼쪽으로 돌리면 → 차가 왼쪽으로

- 전등 스위치
  위로 올리면 → 켜짐 (밝음 = 위)
  아래로 내리면 → 꺼짐 (어둠 = 아래)

- 온도 조절
  빨간색 쪽 → 뜨거움
  파란색 쪽 → 차가움
```

**실전 예시**:

**예시 1: 멀티 윈도우 관리**
```
좋은 매핑 ✅:
MacOS Mission Control
- 3손가락 위로 스와이프 → 모든 창 보기 (위 = 전체 조망)
- 3손가락 좌우 스와이프 → 데스크탑 전환

Windows Snap
- 창을 화면 가장자리로 드래그 → 그 위치에 스냅
- 왼쪽 = 왼쪽 반, 오른쪽 = 오른쪽 반
```

**예시 2: 슬라이더와 컨트롤**
```
좋은 매핑 ✅:
[────●────────] 50%
왼쪽 = 최소 (0%)
오른쪽 = 최대 (100%)
중간 = 중간값

나쁜 매핑 ❌:
[────────────●] 10%
오른쪽이 최소값? (반직관적)
```

**예시 3: 지도 네비게이션**
```
좋은 매핑 ✅:
- 두 손가락 벌림 → 확대
- 두 손가락 오므림 → 축소
- 드래그 → 지도 이동 (직접 조작 느낌)

나쁜 매핑 ❌:
- + 버튼만으로 확대/축소
- 화살표 버튼으로만 이동
- 제스처 불가
```

**실무 적용**:
```scss
레이아웃 매핑:
좌 → 우: 시간 흐름, 진행 방향 (서양 문화권)
위 → 아래: 중요도, 우선순위
중앙: 가장 중요한 요소

컨트롤 매핑:
슬라이더: 
- 수평 → 양 조절 (볼륨, 밝기)
- 수직 → 레벨, 높이

버튼 그룹:
- 기능별로 근접 배치
- 관련된 버튼끼리 묶기
- 위험한 버튼은 분리

색상 매핑:
빨강 → 정지, 위험, 삭제
초록 → 진행, 안전, 확인
파랑 → 정보, 중립
노랑 → 경고, 주의
회색 → 비활성, 보조

방향 매핑:
▲ 위 → 증가, 상승, 과거
▼ 아래 → 감소, 하강, 미래
◀ 왼쪽 → 이전, 뒤로
▶ 오른쪽 → 다음, 앞으로
```

**문화적 차이 고려**:
```
서양 (LTR - Left to Right):
[◀ 이전] [다음 ▶]
왼쪽 = 과거, 오른쪽 = 미래

중동 (RTL - Right to Left):
[다음 ▶] [◀ 이전]
오른쪽 = 과거, 왼쪽 = 미래

→ 글로벌 제품은 문화권별 조정 필요
```

**매핑 테스트 방법**:
```
1. 사용자에게 물어보기
   "이 버튼을 누르면 무슨 일이 일어날 것 같나요?"
   
2. 첫 사용자 테스트
   - 설명 없이 사용하게 하기
   - 어디서 헤매는지 관찰

3. 시선 추적 (Eye Tracking)
   - 사용자가 어디를 먼저 보는가?
   - 기대한 곳을 보는가?

4. A/B 테스트
   - 다른 매핑 방식 비교
   - 어느 쪽이 더 직관적인가?
```

#### 5. **일관성 (Consistency)** 📐

**정의**: 비슷한 요소는 비슷하게 보이고, 비슷한 상황에서는 비슷한 방식으로 작동해야 합니다.

**핵심 원칙**:
- "한 번 배우면 어디서나 적용 가능"
- 예측 가능성 향상
- 학습 비용 감소

**일관성의 4가지 수준**:

**1. 내부 일관성 (Internal Consistency)**
```
같은 제품/서비스 내에서의 일관성

좋은 예 ✅:
- 모든 페이지에서 "저장" 버튼이:
  • 같은 위치 (우측 하단)
  • 같은 색상 (파란색)
  • 같은 크기
  • 같은 아이콘

- 모든 입력란이:
  • 같은 높이 (48px)
  • 같은 테두리 스타일
  • 같은 포커스 효과
  • 같은 에러 표시 방식

나쁜 예 ❌:
- 페이지 A: "저장" 버튼이 우측 하단, 파란색
- 페이지 B: "저장" 버튼이 좌측 상단, 초록색
→ 사용자 혼란
```

**2. 외부 일관성 (External Consistency)**
```
업계 표준 및 다른 제품과의 일관성

좋은 예 ✅:
플랫폼 가이드라인 준수:
- iOS: 네비게이션 바 상단, 탭 바 하단
- Android: 플로팅 액션 버튼 우측 하단
- Web: 로고 좌측 상단, 메뉴 우측 상단

일반적 컨벤션:
- ⚙️ = 설정
- 🔍 = 검색
- 🏠 = 홈
- ❤️ = 좋아요
- 🗑️ = 삭제
- Cmd/Ctrl + C = 복사
- Cmd/Ctrl + V = 붙여넣기

나쁜 예 ❌:
- 기존 앱과 다른 제스처
- 업계 표준과 반대되는 색상 (빨강 = 확인?)
- 독특한 아이콘 (사용자가 학습 필요)
```

**3. 시각적 일관성 (Visual Consistency)**
```
디자인 요소의 통일

디자인 시스템 구성 요소:

색상 (Color):
Primary: #007AFF (주요 행동)
Secondary: #5856D6 (보조 행동)
Success: #34C759
Warning: #FF9500
Error: #FF3B30
Neutral: #8E8E93

타이포그래피 (Typography):
H1: 32px / Bold
H2: 24px / Semibold
H3: 20px / Semibold
Body: 16px / Regular
Caption: 14px / Regular

간격 (Spacing):
8px 시스템 (8, 16, 24, 32, 40, 48...)

버튼 스타일:
Primary Button: 채워진 배경
Secondary Button: 테두리만
Text Button: 텍스트만

아이콘:
같은 스타일 (Line / Filled / Outlined)
같은 굵기 (2px stroke)
같은 크기 (24x24px)
```

**4. 기능적 일관성 (Functional Consistency)**
```
동작과 인터랙션의 통일

좋은 예 ✅:
- 모든 삭제 작업에 확인 다이얼로그
- 모든 폼에서 Enter = 제출
- 모든 목록에서 스와이프 = 삭제
- 모든 모달에서 ESC = 닫기
- 모든 이미지에 줌 기능

나쁜 예 ❌:
- 어떤 삭제는 확인, 어떤 삭제는 바로 실행
- 어떤 페이지는 Enter 제출, 어떤 페이지는 안 됨
```

**실전 예시**:

**예시 1: Apple의 일관성**
```
내부 일관성:
- iOS, iPadOS, macOS, watchOS 모두 비슷한 디자인 언어
- San Francisco 폰트 사용
- 같은 아이콘 세트
- 같은 제스처 (스와이프, 핀치 등)

외부 일관성:
- 업계 표준 준수 (USB-C, Bluetooth)
- 일반적인 제스처 패턴
```

**예시 2: Google Material Design**
```
철학: "물리적 은유"
- 카드는 종이처럼 보임
- 그림자로 깊이 표현
- 모든 Google 제품에 적용
  (Gmail, Drive, Maps, YouTube...)

일관된 컴포넌트:
- Floating Action Button (FAB)
- Bottom Navigation
- Snackbar
- App Bar
```

**예시 3: 온라인 쇼핑몰**
```
일관성 있는 요소:
✅ 모든 상품 카드가 같은 레이아웃
✅ "장바구니 담기" 버튼 항상 같은 위치
✅ 가격 표시 방식 통일
✅ 별점 표시 통일

비일관적인 요소 ❌:
❌ 카테고리마다 다른 필터 위치
❌ 일부는 "구매하기", 일부는 "주문하기"
❌ 할인율 표시 방식이 제각각
```

**실무 적용**:
```scss
디자인 시스템 구축:

1. 토큰 정의 (Design Tokens)
// 색상
$primary-color: #007AFF;
$text-color: #000000;
$background-color: #FFFFFF;

// 간격
$spacing-xs: 4px;
$spacing-sm: 8px;
$spacing-md: 16px;
$spacing-lg: 24px;

// 타이포그래피
$font-size-h1: 32px;
$font-size-body: 16px;
$line-height: 1.5;

2. 컴포넌트 라이브러리
- Button (Primary, Secondary, Text)
- Input (Text, Number, Email, Password)
- Card (Product, Article, Profile)
- Modal (Alert, Confirm, Form)

3. 패턴 라이브러리
- Navigation (Top Nav, Side Nav, Bottom Nav)
- Forms (Login, Signup, Profile Edit)
- Lists (Product List, Article List)
- Feedback (Toast, Snackbar, Alert)

4. 문서화
- Storybook으로 컴포넌트 문서화
- 사용 가이드라인
- Do's and Don'ts
```

**일관성의 예외**:
```
언제 일관성을 깨도 되는가?

1. 중요도 강조
   위험한 "삭제" 버튼 → 빨간색으로 차별화

2. 새로운 기능 소개
   새 기능 → 첫 사용 시 다른 스타일로 강조

3. 플랫폼 특성
   iOS와 Android는 각 플랫폼 가이드라인 따르기

4. 사용자 피드백 반영
   A/B 테스트로 더 나은 방식 발견 시 변경

원칙: 
일관성을 깨는 것은 명확한 이유가 있어야 함
```

**일관성 체크리스트**:
```
□ 모든 버튼이 같은 스타일 시스템을 따르는가?
□ 색상 사용이 일관적인가?
□ 간격(spacing)이 규칙적인가?
□ 아이콘 스타일이 통일되어 있는가?
□ 폰트와 텍스트 스타일이 일관적인가?
□ 에러 메시지 형식이 통일되어 있는가?
□ 로딩 표시 방식이 같은가?
□ 네비게이션 패턴이 일관적인가?
□ 인터랙션이 예측 가능한가?
□ 플랫폼 가이드라인을 따르는가?
```

**일관성의 이점**:
```
1. 학습 비용 감소
   - 한 번 배우면 전체 적용
   - 새 기능도 쉽게 이해

2. 개발 효율성
   - 재사용 가능한 컴포넌트
   - 빠른 개발 속도

3. 브랜드 아이덴티티
   - 일관된 경험
   - 신뢰성 향상

4. 유지보수 용이
   - 한 곳만 수정하면 전체 반영
   - 버그 감소
```

#### 6. **행동 유도성 / 어포던스 (Affordance)** 🎯
객체의 속성이 그것을 어떻게 사용해야 하는지 자연스럽게 알려줍니다.

**핵심 개념:**
- **실제 어포던스 (Actual Affordance)**: 객체가 실제로 제공하는 기능
- **지각된 어포던스 (Perceived Affordance)**: 사용자가 인지하는 행동 가능성
- **시그니파이어 (Signifier)**: 어포던스를 명확하게 알려주는 시각적 신호

**예시:**
- ✅ 좋은 예: 버튼은 눌러야 한다는 것을 시각적으로 표현 (그림자, 입체감)
- ✅ 좋은 예: 밑줄 친 파란색 텍스트 = 클릭 가능한 링크
- ✅ 좋은 예: 문손잡이 = 당기기, 평평한 판 = 밀기
- ❌ 나쁜 예: 평평한 버튼 (클릭 가능한지 불명확)

**실무 적용:**
```
시각적 신호:
- 버튼: 입체감, 그림자, hover 효과
- 링크: 밑줄, 색상 (보통 파란색)
- 입력창: 테두리, 커서 깜빡임
- 드래그 가능: 손 모양 커서
- 비활성화: 회색, 투명도 감소

인터랙션 신호:
- 클릭 가능: 포인터 커서 변경
- 드래그 가능: 잡기 커서 (grab)
- 로딩 중: 대기 커서 (wait)
- 텍스트 선택: I-beam 커서
```

**실전 예시:**
```scss
// iOS 버튼 - 명확한 어포던스
외곽선 버튼 (Secondary)
→ 클릭 가능하지만 덜 중요함을 암시

채워진 버튼 (Primary)  
→ 주요 행동, 눌러달라는 강한 신호

텍스트 버튼 (Tertiary)
→ 선택적 행동, 덜 중요함
```

---

### 행동의 7단계 (Don Norman)

사용자가 목표를 달성하기 위해 거치는 단계입니다.

#### **실행 단계 (Execution)**
1. **목표 설정 (Goal)**: "나는 ~를 하고 싶다"
2. **계획 (Plan)**: "어떻게 할 수 있을까?"
3. **명세화 (Specify)**: "구체적으로 무엇을 해야 하지?"
4. **수행 (Perform)**: "실제로 행동하기"

#### **평가 단계 (Evaluation)**
5. **지각 (Perceive)**: "무슨 일이 일어났지?"
6. **해석 (Interpret)**: "이게 무슨 의미지?"
7. **비교 (Compare)**: "내가 원한 결과와 같은가?"

#### 실전 예시: 카카오톡으로 메시지 보내기

```
1. 목표: 친구에게 메시지를 보내고 싶다
2. 계획: 카카오톡 앱을 열어서 친구를 찾아야겠다
3. 명세화: 앱을 열고 → 친구 목록에서 선택 → 메시지 입력 → 전송
4. 수행: 실제로 클릭하고 타이핑함

5. 지각: 메시지가 채팅방에 표시됨
6. 해석: 메시지가 전송되었구나
7. 비교: 내가 보낸 내용이 맞고, 성공적으로 전송됨 ✅
```

---

### 디자인 실패 사례

#### 🚪 노먼 도어 (Norman Door)
- **문제**: 밀어야 하는 문에 손잡이가 있거나, 당겨야 하는 문에 평평한 판이 있음
- **원인**: 잘못된 어포던스 (Affordance)
- **해결**: 손잡이 = 당기기, 평평한 판 = 밀기

#### 🔥 가스레인지
- **문제**: 버튼 배치가 불판 위치와 매칭되지 않음
- **원인**: 잘못된 매핑 (Mapping)
- **해결**: 버튼을 불판과 동일한 위치에 배치

#### 📱 숨겨진 기능
- **문제**: 중요한 기능이 숨겨진 메뉴에 있음
- **원인**: 가시성 (Visibility) 부족
- **해결**: 주요 기능은 메인 화면에 노출

---

### 디자이너의 역할

#### PM과 디자이너의 협업
- **PM**: "무엇을" 만들지, "왜" 만드는지 정의
- **디자이너**: "어떻게" 만들지, 사용자 경험 설계
- **개발자**: "기술적으로" 어떻게 구현할지 실행

#### 디자인 씽킹 프로세스
```
1. 공감 (Empathize) → 사용자 이해
2. 정의 (Define) → 문제 정의
3. 아이디어 (Ideate) → 해결책 도출
4. 프로토타입 (Prototype) → 시제품 제작
5. 테스트 (Test) → 사용자 테스트 및 개선
```

---

### 핵심 요약

| 원리 | 질문 | 목적 |
|------|------|------|
| **가시성** | "무엇을 할 수 있지?" | 기능 발견 |
| **피드백** | "무슨 일이 일어났지?" | 상태 확인 |
| **제약** | "왜 이게 안 되지?" | 실수 방지 |
| **매핑** | "이게 어떻게 작동하지?" | 직관적 이해 |
| **일관성** | "항상 이렇게 작동하나?" | 학습 용이성 |
| **어포던스** | "이걸 어떻게 써?" | 사용법 암시 |

---

## 멘탈 모델 (Mental Model)

### 멘탈 모델이란?

멘탈 모델은 **사용자가 시스템이 어떻게 작동할 것이라고 '생각하는' 내면의 인지 구조**입니다.

> 사용자의 머릿속에 형성된 제품이나 시스템에 대한 '예상', '기대', '이해'

#### 핵심 개념
```
실제 시스템 ≠ 멘탈 모델
(How it actually works) ≠ (How users think it works)
```

**디자인의 목표**: 사용자의 멘탈 모델과 실제 시스템을 최대한 일치시키는 것

---

### 3가지 모델의 관계

#### 1. **구현 모델 (Implementation Model)** 🔧
시스템이 **실제로** 작동하는 방식

**예시:**
- 이메일이 실제로는 서버 → 프로토콜 → 네트워크를 통해 전송됨
- 파일 저장은 디스크의 섹터에 바이너리 데이터로 기록됨

#### 2. **표현 모델 (Represented Model)** 🎨
디자이너가 사용자에게 **보여주는** 방식

**예시:**
- 이메일 "보내기" 버튼을 클릭하면 종이비행기 아이콘 애니메이션
- 파일을 "휴지통"으로 드래그하면 삭제

#### 3. **멘탈 모델 (Mental Model)** 🧠
사용자가 **생각하는** 방식

**예시:**
- "보내기를 누르면 편지처럼 상대방에게 전달되겠지"
- "휴지통에 버리면 사라지겠지"

---

### 멘탈 모델 형성 과정

#### 사용자는 어떻게 멘탈 모델을 만드는가?

```
과거 경험 + 유사한 제품 + 문화적 배경 + 직접 사용
         ↓
    멘탈 모델 형성
         ↓
    새로운 제품에 적용
```

#### 형성 요소
1. **과거 경험**: "이전에 써본 앱은 이렇게 작동했어"
2. **비유와 은유**: "클라우드는 하늘에 있는 저장소 같은 거야"
3. **문화적 관습**: "빨간색 = 정지/위험, 초록색 = 진행/안전"
4. **학습**: "한 번 써보니까 이렇게 작동하는구나"

---

### 멘탈 모델 활용하기

#### ✅ 좋은 예: 멘탈 모델을 잘 활용한 디자인

**1. 휴지통 (Recycle Bin)**
```
현실 세계의 은유:
- 휴지통에 버리면 → 삭제되지만 복구 가능
- 휴지통을 비우면 → 완전히 삭제
```
→ 사용자의 멘탈 모델과 정확히 일치!

**2. 폴더 (Folder)**
```
현실 세계의 은유:
- 폴더 안에 파일을 넣는다
- 폴더를 열면 내용물이 보인다
- 폴더를 다른 폴더 안에 넣을 수 있다
```
→ 직관적으로 이해 가능

**3. 쇼핑 카트 (Shopping Cart)**
```
현실 세계의 은유:
- 상품을 카트에 담는다
- 계속 쇼핑할 수 있다
- 결제 전까지 담은 물건을 빼거나 수정 가능
```
→ 오프라인 쇼핑 경험 그대로

---

#### ❌ 나쁜 예: 멘탈 모델을 위배한 디자인

**1. "저장" 아이콘이 플로피 디스크** 💾
```
문제점:
- 2000년대 이후 세대는 플로피 디스크를 본 적이 없음
- 멘탈 모델 형성 불가능
해결책:
- "저장" 텍스트 라벨 추가
- 클라우드 아이콘으로 대체
```

**2. 햄버거 메뉴 (☰)**
```
문제점:
- 처음 보는 사용자는 이게 메뉴인지 모름
- "3줄 = 메뉴"라는 학습이 필요
해결책:
- "메뉴" 텍스트 라벨 추가
- 처음 사용 시 툴팁 표시
```

**3. 제스처 기반 인터페이스**
```
문제점:
- 숨겨진 제스처는 발견하기 어려움
- 각 앱마다 제스처가 다르면 혼란
해결책:
- 온보딩에서 제스처 안내
- 업계 표준 제스처 사용
```

---

### 멘탈 모델 간극 (Mental Model Gap)

#### 간극이 발생하는 경우

```
사용자 멘탈 모델: "이렇게 작동할 거야"
         ↓
        [ 간극 ]
         ↓
  실제 시스템: "사실은 이렇게 작동해"
```

#### 간극의 결과
- 😕 혼란: "왜 이렇게 작동하지?"
- 😤 좌절: "왜 안 되는 거야?"
- 🚫 포기: "이거 못 쓰겠다"

---

### 멘탈 모델 간극 줄이기

#### 1. **친숙한 은유 사용** 🎯
```scss
// 나쁜 예
"데이터 동기화" (기술 용어)

// 좋은 예  
"최신 상태로 업데이트" (친숙한 표현)
```

#### 2. **명확한 시각적 단서** 👁️
```scss
// 나쁜 예
평평한 버튼 (클릭 가능한지 불명확)

// 좋은 예
그림자가 있는 입체적 버튼 (명확히 클릭 가능)
```

#### 3. **일관된 패턴** 📐
```scss
// 나쁜 예
페이지마다 다른 네비게이션 위치

// 좋은 예
모든 페이지에서 동일한 네비게이션
```

#### 4. **즉각적인 피드백** 💬
```scss
// 나쁜 예
버튼 클릭 후 아무 반응 없음

// 좋은 예
클릭 → 색상 변화 → 로딩 → 완료 메시지
```

#### 5. **온보딩과 가이드** 📚
```scss
// 새로운 개념을 소개할 때
1. 짧은 튜토리얼
2. 툴팁으로 설명
3. 도움말 센터 링크
```

---

### 멘탈 모델 리서치 방법

#### 사용자의 멘탈 모델 파악하기

**1. 사용자 인터뷰**
```
질문 예시:
- "이 버튼을 클릭하면 무슨 일이 일어날 것 같나요?"
- "이 기능이 어떻게 작동한다고 생각하시나요?"
- "왜 그렇게 생각하셨나요?"
```

**2. 카드 소팅 (Card Sorting)**
```
방법:
- 기능 카드를 사용자가 그룹화
- 사용자가 카테고리 이름 지정
→ 사용자의 정보 구조 이해
```

**3. 사용성 테스트 (Usability Test)**
```
관찰:
- 사용자가 어디서 헤매는가?
- 어떤 버튼을 눌러야 할지 고민하는가?
- 기대와 다른 결과에 놀라는가?
```

**4. Think Aloud Protocol**
```
방법:
- 사용자에게 생각을 소리 내어 말하게 함
- "지금 뭘 하려고 하시나요?"
- "이게 뭘 하는 버튼이라고 생각하시나요?"
```

---

### 실전 예시

#### 예시 1: iOS 사진 앱의 "앨범"

```
멘탈 모델:
📷 "앨범에 사진을 넣으면, 원본이 이동하는 거겠지?"

실제 구현:
📷 "앨범은 사진을 '참조'만 하고, 원본은 그대로 있어요"

결과:
✅ 한 사진을 여러 앨범에 넣을 수 있음
✅ 앨범에서 삭제해도 원본은 남음

디자인 결정:
→ 사용자 교육 필요
→ "앨범에서 제거" vs "사진 삭제" 명확히 구분
```

#### 예시 2: 윈도우의 "바로가기"

```
멘탈 모델:
💾 "바로가기는 파일의 복사본이겠지?"

실제 구현:
💾 "바로가기는 원본 파일을 가리키는 포인터예요"

결과:
✅ 바로가기는 용량을 거의 차지하지 않음
⚠️ 원본을 삭제하면 바로가기가 작동하지 않음

디자인 결정:
→ 바로가기 아이콘에 화살표 표시
→ 원본이 없으면 에러 메시지
```

#### 예시 3: 드래그 앤 드롭

```
멘탈 모델:
🖱️ "파일을 다른 폴더로 드래그하면 이동하겠지?"

실제 구현:
🖱️ "같은 드라이브면 이동, 다른 드라이브면 복사"

문제점:
❌ 사용자가 예측하기 어려움

해결책:
✅ 드래그 중 커서 모양으로 알려주기 (➕ 복사, ↗️ 이동)
✅ Shift/Ctrl 키로 명확히 지정 가능
```

---

### 멘탈 모델 디자인 체크리스트

디자인할 때 다음을 자문해보세요:

- [ ] 사용자가 이 기능을 어떻게 이해할까?
- [ ] 사용자의 과거 경험과 일치하는가?
- [ ] 현실 세계의 은유를 사용할 수 있는가?
- [ ] 사용자가 예상하는 대로 작동하는가?
- [ ] 예상과 다르다면, 명확히 설명했는가?
- [ ] 업계 표준/관습을 따르고 있는가?
- [ ] 처음 보는 사용자도 직관적으로 이해할 수 있는가?

---

### 핵심 요약

| 개념 | 설명 | 예시 |
|------|------|------|
| **멘탈 모델** | 사용자가 생각하는 작동 방식 | "휴지통 = 쓰레기통" |
| **구현 모델** | 실제 작동 방식 | "파일 시스템 플래그 변경" |
| **표현 모델** | 디자이너가 보여주는 방식 | "휴지통 아이콘, 드래그 앤 드롭" |
| **간극** | 멘탈 모델 ≠ 실제 시스템 | 혼란, 좌절, 포기 |
| **목표** | 간극 최소화 | 직관적 인터페이스 |

**멘탈 모델을 존중하는 디자인 = 사용자 친화적 디자인**

---

## 개인(그룹) 과제
1. 좋은 디자인을 가졌다고 생각하는 프로덕트를 하나 선정합니다.
2. 해당 프로덕트의 주요 기능을 하나 선택해 해당 기능을 사용하는 절차에 대해 행동의 7단계에 기반하여 분석을 합니다.
3. 이 행동을 유도하기 위한 디자인 요소를 검토하고 이를 6가지 좋은 디자인의 원리에 맞게 잘 설계되었는지 검토합니다. 
4. 이 과정에서 어떤 인사이트를 발견했는지 논의하고 이를 정리해 봅니다.

## 과제

## 그룹 연구 과제
1. 좋은 디자인을 가졌다고 생각하는 프로덕트를 하나 선정합니다.
2. 해당 프로덕트의 주요 기능을 하나 선택해 해당 기능을 사용하는 절차에 대해 행동의 7단계에 기반하여 분석을 합니다.
3. 이 행동을 유도하기 위한 디자인 요소를 검토하고 이를 6가지 좋은 디자인의 원리에 맞게 잘 설계되었는지 검토합니다. 
4. 이 과정에서 어떤 인사이트를 발견했는지 논의하고 이를 정리해 봅니다.


## 참고 자료

### 강의 자료
- [1강 개인(그룹)과제 PDF](/assets/pdf/goormuiux1gw.pdf)

### 학습 자료 및 출처

#### 📚 서적
- **"The Design of Everyday Things"** - Don Norman (2013)
  - 디자인의 6가지 원리, 행동의 7단계, 멘탈 모델 개념
  - 노먼 도어, 어포던스, 시그니파이어 등 핵심 개념
  
- **"Don't Make Me Think"** - Steve Krug (2014)
  - 웹 사용성, 직관적 디자인 원칙

- **"Universal Principles of Design"** - William Lidwell, Kritina Holden, Jill Butler (2010)
  - 디자인 원칙과 멘탈 모델 적용 사례

#### 🌐 온라인 리소스
- **Nielsen Norman Group** - [nngroup.com](https://www.nngroup.com/)
  - UX 리서치, 사용성 테스트 방법론
  - 멘탈 모델 연구 및 사례 연구

- **Interaction Design Foundation** - [interaction-design.org](https://www.interaction-design.org/)
  - 디자인 씽킹, UX 디자인 원칙
  - 무료 UX 교육 자료

- **Laws of UX** - [lawsofux.com](https://lawsofux.com/)
  - UX 디자인 법칙과 심리학적 원리
  - 시각적 예시와 실무 적용 방법

#### 📖 개념 정리
- **어포던스 (Affordance)** - J.J. Gibson의 생태심리학 이론 (1977)
- **시그니파이어 (Signifier)** - Don Norman이 어포던스 개념을 확장 (2013)
- **피츠의 법칙 (Fitts's Law)** - Paul Fitts (1954)
- **힉의 법칙 (Hick's Law)** - William Edmund Hick (1952)

#### 🎓 관련 강의 및 코스
- **Human-Computer Interaction (HCI)** - Stanford University
- **Design Thinking** - IDEO U
- **User Experience Design Fundamentals** - Coursera

#### 💡 실무 사례 참고
- Apple Human Interface Guidelines
- Google Material Design
- Microsoft Fluent Design System
- Nielsen Norman Group Case Studies

---

### 추가 학습 자료

#### 유튜브 채널
- **The Futur** - 디자인 비즈니스와 실무
- **Maex** - UX/UI 디자인 튜토리얼
- **DesignCourse** - UI/UX 디자인 실전

#### 커뮤니티
- **UX Collective** (Medium)
- **Smashing Magazine**
- **A List Apart**

#### 도구 및 프로토타이핑
- Figma - [figma.com](https://www.figma.com/)
- Adobe XD
- Sketch
- InVision

