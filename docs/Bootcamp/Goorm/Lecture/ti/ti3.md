---
layout: default
nav_order: 3
title: TI - 생성형 AI의 이해
description: "Technology Trends and Industry Insights 3"
parent: TI
grand_parent: Goorm
has_children: false
---

# 제 3 강 - 생성형 AI의 이해

## 사전 질문
1. 생성형 AI가 기존의 AI와 다른 제일 큰 차이점은 무엇인가요? 가능한 기술적 관점에서 설명해 봅니다.
    - 기존 AI는 데이터를 기반하여 프롬프터의 질문에 답을 분류하여 예측 하였지만 생성형은 데이터 분포 자체를 학습하여  샘플링 후 새로운 데이터를 생성해 내어 답변해줍니다.
2. 생성형 AI를 프로덕트 성공에 활용하기 위해 추가적으로 고려해야 하는 요소들은 무엇이 있을까요? 이를 인식하고 적용하기 위해 필요한 역량은 무엇일까요?
    - 서비스의 타겟 고객(퍼소나)에 대한 충분한 분석을 통해 입력 설계를 고려해야 합니다.
    - 고객분석 역량, 사용자 경험에 따른 입력설계 등

## 생성형 AI

### 생성형 AI란?

**생성형 AI(Generative AI)**는 학습된 데이터 패턴을 바탕으로 **새로운 콘텐츠를 창작**하는 인공지능입니다.

**기존 AI vs 생성형 AI**:

| 구분 | 기존 AI | 생성형 AI |
|------|---------|-----------|
| **목적** | 분류, 예측, 판단 | 새로운 콘텐츠 생성 |
| **출력** | 라벨, 점수, 예측값 | 텍스트, 이미지, 코드 등 |
| **예시** | 스팸 필터, 추천 시스템 | ChatGPT, DALL-E, Midjourney |
| **학습 방식** | 데이터 → 패턴 분류 | 데이터 분포 학습 → 샘플링 |

**생성형 AI의 핵심 특징**:
- 학습 데이터를 **복사하지 않고** 새로운 결과물 생성
- **확률적 샘플링**을 통해 매번 다른 출력 가능
- 사용자 입력(프롬프트)에 따라 결과가 달라짐

---

### 생성형 AI의 종류

#### 텍스트 생성 AI

**정의**: 자연어를 이해하고 생성하는 AI

**대표 모델**:
- **GPT-4, GPT-4o** (OpenAI): 대화, 글쓰기, 코딩
- **Claude** (Anthropic): 긴 문맥 처리, 안전성 강조
- **Gemini** (Google): 멀티모달 통합
- **LLaMA** (Meta): 오픈소스 LLM

**활용 사례**:
```
- 챗봇 및 고객 상담
- 콘텐츠 작성 (블로그, 마케팅 카피)
- 요약 및 번역
- 코드 생성 및 디버깅
```

---

#### 이미지 생성 AI

**정의**: 텍스트 설명(프롬프트)으로부터 이미지를 생성하는 AI

**대표 모델**:
- **DALL-E 3** (OpenAI): 텍스트-이미지 변환
- **Midjourney**: 예술적 스타일 특화
- **Stable Diffusion** (Stability AI): 오픈소스, 로컬 실행 가능
- **Adobe Firefly**: 상업적 사용에 안전한 학습 데이터

**활용 사례**:
```
- 마케팅 비주얼 제작
- 제품 목업 및 프로토타입
- 게임/영화 컨셉 아트
- 개인화된 이미지 콘텐츠
```

---

#### 오디오 생성 AI

**정의**: 음성, 음악, 사운드를 생성하는 AI

**대표 모델**:
- **ElevenLabs**: 고품질 음성 합성 (TTS)
- **Suno AI**: 텍스트로 음악 생성
- **OpenAI Whisper**: 음성 인식 (STT)
- **MusicLM** (Google): 텍스트-음악 변환

**활용 사례**:
```
- 오디오북 및 팟캐스트 제작
- 게임/영상 배경 음악
- 다국어 더빙 및 음성 현지화
- 접근성 향상 (시각 장애인용 콘텐츠)
```

---

#### 코드 생성 AI

**정의**: 자연어 설명을 코드로 변환하거나, 코드를 자동 완성하는 AI

**대표 모델**:
- **GitHub Copilot** (OpenAI Codex 기반): IDE 통합 코드 완성
- **Claude Code** (Anthropic): 에이전틱 코딩 도구
- **Amazon CodeWhisperer**: AWS 통합
- **Cursor**: AI 네이티브 코드 에디터

**활용 사례**:
```
- 코드 자동 완성 및 생성
- 버그 탐지 및 수정 제안
- 코드 리뷰 및 최적화
- 테스트 코드 자동 생성
```

---

### 생성형 AI의 기본 원리

생성형 AI는 **대량의 데이터에서 패턴을 학습**하고, 이를 바탕으로 **새로운 데이터를 생성**합니다.

**핵심 원리**:
```
1. 학습 (Training)
   - 대량의 데이터에서 통계적 패턴 학습
   - "고양이" 다음에 어떤 단어가 올 확률이 높은지 학습

2. 생성 (Generation)
   - 학습된 패턴을 기반으로 다음 토큰 예측
   - 확률적 샘플링으로 다양한 출력 생성

3. 조건부 생성 (Conditional Generation)
   - 사용자 입력(프롬프트)을 조건으로 생성 방향 결정
   - 같은 모델이라도 프롬프트에 따라 다른 결과
```

---

### 언어 모델이란?

**언어 모델(Language Model)**은 주어진 텍스트 시퀀스의 **다음에 올 단어(토큰)의 확률**을 예측하는 모델입니다.

**대규모 언어 모델(LLM)**:
- **L**arge: 수십억~수조 개의 파라미터
- **L**anguage: 자연어 처리에 특화
- **M**odel: 신경망 기반 모델

**핵심 개념**:
```
"오늘 날씨가 정말 ___"

모델 예측:
- "좋다" (35%)
- "덥다" (25%)
- "춥다" (20%)
- "흐리다" (10%)
- 기타 (10%)

→ 확률에 따라 하나를 선택 (샘플링)
```

---

#### 언어 모델의 핵심 처리 흐름

**1. 토큰화 (Tokenization)**

텍스트를 모델이 처리할 수 있는 최소 단위로 분할

```
입력: "안녕하세요, 반갑습니다"
토큰화: ["안녕", "하세요", ",", " 반갑", "습니다"]

영어 예시:
입력: "Hello, world!"
토큰화: ["Hello", ",", " world", "!"]
```

**특징**:
- 단어 단위가 아닌 **서브워드(subword)** 단위
- 희귀 단어도 조합으로 표현 가능
- 모델마다 토크나이저가 다름

---

**2. 임베딩 (Embedding)**

토큰을 고차원 벡터 공간에 표현

```
"왕" → [0.2, -0.5, 0.8, ...]  (수백~수천 차원)
"여왕" → [0.3, -0.4, 0.7, ...]

벡터 연산:
"왕" - "남자" + "여자" ≈ "여왕"
```

**역할**:
- 단어의 **의미적 관계**를 수치로 표현
- 유사한 의미의 단어는 가까운 벡터
- 문맥에 따라 동적으로 변화 (Contextual Embedding)

---

**3. 자기 주의 메커니즘 (Self-Attention)**

문장 내 모든 단어 간의 관계를 동시에 파악

```
"그 은행에서 돈을 찾았다"
        ↓
"은행" 해석 시:
- "돈"과의 관계 → 금융 기관 (높은 가중치)
- "강"이 없음 → 강둑 의미 배제

"강 옆 은행에 앉았다"
        ↓
"은행" 해석 시:
- "강"과의 관계 → 강둑 (높은 가중치)
- "앉았다" → 물리적 장소
```

**핵심**:
- **Query, Key, Value** 메커니즘
- 모든 토큰이 서로를 참조
- 문맥에 따른 동적 의미 파악

---

**4. 다층 신경망 처리 (Multi-layer Processing)**

여러 층의 Transformer 블록을 통과하며 정보 처리

```
입력 → [Layer 1] → [Layer 2] → ... → [Layer N] → 출력
         ↓           ↓                    ↓
      기초 패턴    문법 구조           고차원 의미
      (품사, 형태)  (주어-동사)         (의도, 맥락)
```

**GPT-4 규모**:
- 약 100개 이상의 레이어
- 수천억 개의 파라미터
- 각 레이어가 점점 더 추상적인 특징 학습

---

#### 텍스트 생성 과정 상세

**1. 문맥 이해 (Context Understanding)**

입력 프롬프트 전체를 분석하여 의도 파악

```
프롬프트: "파이썬으로 피보나치 수열을 계산하는 함수를 작성해줘"

문맥 분석:
- 언어: 파이썬
- 작업: 함수 작성
- 대상: 피보나치 수열
- 형식: 코드 블록 예상
```

---

**2. 확률 분포 계산 (Probability Distribution)**

다음 토큰의 확률 분포 계산

```
"def fibonacci(" 다음 토큰 확률:

"n"     → 45%  ← 선택됨
"num"   → 20%
"x"     → 10%
"index" → 8%
기타    → 17%
```

---

**3. 토큰 선택 및 생성 (Token Sampling)**

확률에 따라 토큰 선택 (샘플링 전략)

**Temperature 파라미터**:
```
Temperature = 0 (결정적)
→ 항상 가장 높은 확률의 토큰 선택
→ 일관된 출력, 창의성 낮음

Temperature = 1 (균형)
→ 확률에 비례하여 샘플링
→ 적절한 다양성

Temperature > 1 (창의적)
→ 낮은 확률 토큰도 선택 가능
→ 다양하지만 불안정할 수 있음
```

---

**4. 반복 생성 (Autoregressive Generation)**

생성된 토큰을 입력에 추가하여 반복

```
Step 1: "def fibonacci(" → "n"
Step 2: "def fibonacci(n" → ")"
Step 3: "def fibonacci(n)" → ":"
Step 4: "def fibonacci(n):" → "\n"
Step 5: "def fibonacci(n):\n" → "    "
...
→ 종료 토큰 또는 최대 길이까지 반복
```

---

### 언어 모델(LLM)의 주요 한계

#### 지식 컷오프 (Knowledge Cutoff)

**정의**: 학습 데이터 이후의 정보를 알지 못함

**예시**:
```
질문: "2025년 노벨 물리학상 수상자는?"
문제: 2024년까지 학습된 모델 → 답변 불가

질문: "어제 발표된 애플 신제품은?"
문제: 실시간 정보 없음 → 부정확하거나 거부
```

**영향**:
- 최신 정보가 필요한 서비스에 한계
- 시간에 민감한 질문에 오래된 정보 제공 위험

**해결 방안**:
- RAG (외부 지식 검색 결합)
- 웹 검색 기능 통합
- 정기적인 모델 업데이트

---

#### 환각 (Hallucination)

**정의**: 그럴듯하지만 **사실이 아닌 정보**를 생성

**예시**:
```
질문: "아인슈타인의 1950년 논문 제목은?"
환각: "우주 통일장 이론에 관한 고찰" (실제로 없는 논문)

질문: "이 약의 부작용은?"
환각: 존재하지 않는 부작용 나열 (의료 위험)
```

**원인**:
- 학습 데이터의 패턴 과일반화
- "다음 토큰 예측"의 본질적 한계
- 확률적 생성으로 인한 불확실성

**영향**:
- 잘못된 정보로 인한 의사결정 오류
- 사용자 신뢰도 저하
- 법적/의료적 위험

---

#### 출처 추적 불가 (Lack of Attribution)

**정의**: 생성된 정보의 **원본 출처를 제시하지 못함**

**예시**:
```
질문: "기후 변화의 주요 원인은?"
응답: "화석 연료 사용이 주요 원인입니다."
문제: 어떤 연구/논문/기관의 정보인지 알 수 없음
```

**영향**:
- 정보의 신뢰성 검증 어려움
- 학술/전문 영역에서 활용 제한
- 저작권 및 표절 문제

**해결 방안**:
- RAG로 검색된 문서 출처 표시
- 인용 기능이 있는 서비스 활용 (Perplexity 등)

---

#### 맞춤형 지식 부재 (Lack of Domain Knowledge)

**정의**: 특정 조직/도메인의 **비공개 정보를 알지 못함**

**예시**:
```
질문: "우리 회사 인사 규정에서 연차 사용 규칙은?"
문제: 내부 문서를 학습하지 않아 답변 불가

질문: "지난달 매출 데이터 분석해줘"
문제: 회사 데이터베이스 접근 불가
```

**영향**:
- 기업 내부 업무 활용 제한
- 개인화된 서비스 어려움

**해결 방안**:
- RAG로 내부 문서 연결
- Fine-tuning으로 도메인 특화
- 에이전트를 통한 외부 시스템 연동

---

### RAG (Retrieval-Augmented Generation)

**RAG**는 LLM의 한계를 보완하기 위해 **외부 지식 검색**과 **생성**을 결합한 기법입니다.

**핵심 아이디어**:
```
기존 LLM:
프롬프트 → [LLM] → 응답 (학습된 지식만 사용)

RAG:
프롬프트 → [검색] → 관련 문서 → [LLM + 문서] → 응답
```

**장점**:
- 최신 정보 반영 가능
- 출처 명시 가능
- 환각 감소
- 도메인 특화 가능

---

#### RAG 주요 구성 흐름

```
┌─────────────────────────────────────────────────────┐
│                      RAG 파이프라인                    │
├─────────────────────────────────────────────────────┤
│                                                     │
│   사용자 질문                                        │
│       ↓                                             │
│   ┌─────────────┐                                   │
│   │  임베딩 생성  │  질문을 벡터로 변환                │
│   └─────────────┘                                   │
│       ↓                                             │
│   ┌─────────────┐    ┌─────────────┐               │
│   │  벡터 검색   │ ←→ │ 벡터 DB     │  유사 문서 검색  │
│   └─────────────┘    │ (Pinecone,  │               │
│       ↓              │  Chroma 등) │               │
│   관련 문서 Top-K     └─────────────┘               │
│       ↓                                             │
│   ┌─────────────┐                                   │
│   │ 프롬프트 구성 │  질문 + 검색된 문서 결합           │
│   └─────────────┘                                   │
│       ↓                                             │
│   ┌─────────────┐                                   │
│   │    LLM      │  문서 기반 응답 생성               │
│   └─────────────┘                                   │
│       ↓                                             │
│   최종 응답 (+ 출처)                                 │
│                                                     │
└─────────────────────────────────────────────────────┘
```

**단계별 설명**:

1. **문서 준비 (Indexing)**
   - 문서를 청크(chunk)로 분할
   - 각 청크를 임베딩 벡터로 변환
   - 벡터 데이터베이스에 저장

2. **검색 (Retrieval)**
   - 사용자 질문을 임베딩
   - 벡터 유사도로 관련 문서 검색
   - Top-K 문서 선택

3. **생성 (Generation)**
   - 질문 + 검색된 문서로 프롬프트 구성
   - LLM이 문서 기반 응답 생성

---

#### RAG의 적용

**적용 사례**:

```
1. 기업 내부 지식 관리
   - 사내 문서, 규정, 매뉴얼 검색
   - 신입 직원 온보딩 챗봇

2. 고객 지원
   - FAQ, 제품 매뉴얼 기반 응답
   - 이전 티켓 기반 해결책 제안

3. 법률/의료 전문 서비스
   - 판례, 논문, 가이드라인 검색
   - 출처 명시 필수 영역

4. 실시간 정보 서비스
   - 뉴스, 주식, 날씨 등 최신 정보
   - Perplexity AI 스타일 검색 엔진
```

**고려 사항**:
- 청크 크기와 오버랩 최적화
- 검색 품질 (Precision vs Recall)
- 비용 (임베딩 + LLM 호출)
- 문서 업데이트 주기

---

### 이미지 생성 AI란?

**이미지 생성 AI**는 텍스트 설명(프롬프트)을 입력받아 **시각적 콘텐츠를 생성**하는 AI입니다.

**발전 과정**:
```
GAN (2014)        → 실제 같은 이미지 생성
VAE (2013)        → 이미지 변형/보간
Diffusion (2020~) → 고품질, 다양성, 제어 가능
```

---

#### 확산 모델 (Diffusion Models)이란?

**확산 모델**은 현재 이미지 생성 AI의 핵심 기술로, **노이즈 제거 과정**을 통해 이미지를 생성합니다.

**핵심 아이디어**:
```
순방향 (학습):
깨끗한 이미지 → 점진적으로 노이즈 추가 → 완전한 노이즈

역방향 (생성):
완전한 노이즈 → 점진적으로 노이즈 제거 → 깨끗한 이미지
```

**비유**:
```
잉크가 물에 퍼지는 과정을 역재생
- 순방향: 잉크 한 방울 → 균일하게 퍼짐
- 역방향: 균일한 색 → 원래 잉크 방울 형태로
```

---

#### 확산 모델의 흐름

```
학습 단계 (Forward Process):
┌────────┐   노이즈   ┌────────┐   노이즈   ┌────────┐
│ 원본   │ ────────→ │ 중간   │ ────────→ │ 노이즈 │
│ 이미지 │   추가    │ 상태   │   추가    │ (가우시안)│
└────────┘           └────────┘           └────────┘
   t=0                  t=500               t=1000

생성 단계 (Reverse Process):
┌────────┐  노이즈   ┌────────┐  노이즈   ┌────────┐
│ 노이즈 │ ────────→ │ 중간   │ ────────→ │ 생성된 │
│ (랜덤) │   제거    │ 상태   │   제거    │ 이미지 │
└────────┘           └────────┘           └────────┘
   t=1000               t=500                t=0
              ↑                    ↑
         프롬프트 조건         프롬프트 조건
```

---

#### 이미지를 만드는 과정

**1. 프롬프트를 받아 "의미"를 이해한다**

```
프롬프트: "A cat wearing a space helmet on Mars"

텍스트 인코더 (CLIP 등):
- "cat" → 고양이 특징 벡터
- "space helmet" → 우주 헬멧 특징 벡터
- "Mars" → 화성 배경 특징 벡터
- 조합 → 통합 조건 벡터
```

---

**2. 무작위 노이즈 이미지를 만든다**

```
초기 상태:
- 완전한 가우시안 노이즈 (TV 지지직 화면)
- 어떤 정보도 담고 있지 않음
- 시드(seed) 값에 따라 다른 노이즈
```

---

**3. 프롬프트 의미를 반영하며 노이즈를 줄인다**

```
Step 1 (t=1000→900):
  노이즈에서 대략적인 형태 출현 (덩어리)

Step 2 (t=900→700):
  고양이 실루엣, 헬멧 형태 형성

Step 3 (t=700→400):
  디테일 추가 (털, 헬멧 반사광)

Step 4 (t=400→100):
  화성 배경, 세부 텍스처 완성

Step 5 (t=100→0):
  최종 정리 및 선명화
```

---

**4. 최종적으로 고해상도 이미지를 만든다**

```
저해상도 생성 (64x64 또는 256x256)
        ↓
업스케일링 (Super-Resolution)
        ↓
고해상도 이미지 (1024x1024+)
```

---

#### 프롬프트에 맞는 이미지를 만들기 위한 메커니즘

##### 조건부 생성 메커니즘 (Conditioning)

노이즈 제거 과정에서 **프롬프트 정보를 조건으로 주입**

```
일반 확산:
노이즈 → 모델 → 이미지 (무작위)

조건부 확산:
노이즈 + 조건(프롬프트) → 모델 → 이미지 (조건 반영)
```

**방법**:
- **Cross-Attention**: 텍스트 임베딩과 이미지 특징 연결
- **Classifier-Free Guidance**: 조건 있는/없는 생성 비교로 조건 강화

---

##### 주의 메커니즘 (Attention in Diffusion)

이미지의 **어떤 부분**에 프롬프트의 **어떤 단어**가 영향을 미치는지 결정

```
프롬프트: "A red car on a blue road"

Attention Map:
- "red" → 자동차 영역에 높은 가중치
- "blue" → 도로 영역에 높은 가중치
- "car" → 중앙 객체에 집중
```

**Self-Attention**: 이미지 내 영역 간 관계
**Cross-Attention**: 텍스트와 이미지 영역 간 관계

---

### 멀티모달 AI

**멀티모달 AI**는 **여러 종류의 입출력**을 동시에 처리하는 AI입니다.

```
텍스트 ↔ 이미지 ↔ 오디오 ↔ 비디오
```

**대표 모델**:
- **GPT-4o** (OpenAI): 텍스트, 이미지, 음성 통합
- **Gemini** (Google): 네이티브 멀티모달
- **Claude 3.5** (Anthropic): 텍스트 + 이미지 이해

---

#### 멀티모달 AI의 주요 특징

**1. 다중 입력 처리**
```
예시: 이미지 + 질문 → 답변
"이 차트에서 매출이 가장 높은 달은?"
→ 차트 이미지 분석 + 질문 이해 → "8월입니다"
```

**2. 다중 출력 생성**
```
예시: 텍스트 → 이미지 + 텍스트
"고양이 일러스트를 그려주고 설명해줘"
→ 이미지 생성 + 설명 텍스트
```

**3. 모달리티 간 변환**
```
- 이미지 → 텍스트 (캡셔닝)
- 텍스트 → 이미지 (생성)
- 음성 → 텍스트 (STT)
- 텍스트 → 음성 (TTS)
```

---

#### 멀티모달 AI의 기본 작동 방식

```
┌─────────────────────────────────────────┐
│           멀티모달 AI 구조              │
├─────────────────────────────────────────┤
│                                         │
│   텍스트 ──→ [텍스트 인코더]            │
│                    ↓                    │
│   이미지 ──→ [이미지 인코더] → [통합    │
│                    ↓          공간]    │
│   오디오 ──→ [오디오 인코더]    ↓       │
│                              [디코더]   │
│                                  ↓      │
│                            출력 생성    │
│                                         │
└─────────────────────────────────────────┘
```

**핵심**:
- 각 모달리티를 **공통 임베딩 공간**으로 변환
- 통합된 표현에서 관계 학습
- 원하는 모달리티로 디코딩

---

### 프롬프트의 구성 요소

효과적인 프롬프트는 **5가지 핵심 요소**로 구성됩니다.

---

#### 지시문 (Instruction)

**정의**: AI가 수행해야 할 **작업을 명확히 지시**

**예시**:
```
❌ 약한 지시문:
"마케팅에 대해 알려줘"

✅ 강한 지시문:
"B2B SaaS 제품의 콘텐츠 마케팅 전략을 3가지 제안해줘.
각 전략에 대해 목표, 채널, 예상 결과를 포함해줘."
```

**팁**:
- 동사로 시작 (작성해줘, 분석해줘, 비교해줘)
- 구체적인 행동 명시
- 하나의 프롬프트에 하나의 주요 작업

---

#### 컨텍스트 (Context)

**정의**: 작업 수행에 필요한 **배경 정보 제공**

**예시**:
```
컨텍스트:
"나는 초기 스타트업의 PM이다. 우리 제품은 B2B HR 솔루션이고,
현재 MAU 500명, 월 구독료 5만원이다. 시리즈 A 투자를 준비 중이다."

질문:
"다음 분기 성장 전략을 제안해줘"
```

**포함할 정보**:
- 역할/상황
- 목표/제약
- 관련 데이터
- 이전 맥락

---

#### 입력 데이터 (Input Data)

**정의**: AI가 처리해야 할 **구체적인 데이터**

**예시**:
```
입력 데이터:
"""
고객 리뷰 1: "앱이 자주 크래시됩니다. 특히 결제 화면에서요."
고객 리뷰 2: "UI는 예쁜데 로딩이 너무 느려요."
고객 리뷰 3: "고객센터 응대가 친절했습니다."
"""

지시문:
"위 리뷰를 긍정/부정으로 분류하고, 주요 이슈를 정리해줘"
```

**형식**:
- 명확한 구분자 사용 (""", ---, ###)
- 구조화된 형태 (JSON, 표)
- 필요시 라벨링

---

#### 출력 형식 (Output Format)

**정의**: 원하는 **응답의 형식과 구조** 지정

**예시**:
```
출력 형식:
"다음 형식으로 답변해줘:

## 요약
(1-2문장)

## 주요 포인트
- 포인트 1
- 포인트 2
- 포인트 3

## 결론
(1문장)"
```

**옵션**:
- 마크다운, JSON, 표
- 글자 수/문장 수 제한
- 톤앤매너 (전문적, 친근한)

---

#### 제약 조건 (Constraints)

**정의**: 응답에 대한 **제한과 규칙**

**예시**:
```
제약 조건:
- 500자 이내로 작성
- 전문 용어 사용 자제, 초보자도 이해 가능하게
- 부정적인 표현 피하기
- 한국어로 답변
- 예시는 한국 시장 기준으로
```

**유형**:
- 길이 제한
- 언어/톤
- 포함/제외할 내용
- 형식 규칙

---

### 고급 프롬프트 기법

---

#### 프롬프트 체이닝 (Prompt Chaining)

**정의**: 복잡한 작업을 **여러 단계의 프롬프트로 분할**

**예시**:
```
Step 1: "이 문서의 핵심 주제 3가지를 추출해줘"
        → 주제 A, B, C

Step 2: "주제 A에 대해 자세히 분석해줘"
        → 분석 결과

Step 3: "분석 결과를 바탕으로 실행 계획을 수립해줘"
        → 실행 계획
```

**장점**:
- 각 단계의 품질 향상
- 중간 결과 검토 가능
- 복잡한 작업 분해

---

#### 자기 비평 유도 (Self-Critique)

**정의**: AI가 자신의 답변을 **스스로 검토하고 개선**

**예시**:
```
"다음 비즈니스 전략을 작성해줘.

완료 후, 다음 관점에서 스스로 비평해줘:
1. 논리적 허점은 없는가?
2. 실행 가능성은 있는가?
3. 빠진 고려사항은 없는가?

비평을 반영하여 개선된 버전을 다시 작성해줘."
```

---

#### 다중 관점 추론 (Multi-Perspective Reasoning)

**정의**: **여러 관점**에서 문제를 분석

**예시**:
```
"이 제품 출시 결정에 대해 다음 관점에서 각각 분석해줘:

1. CEO 관점: 비즈니스 성장과 리스크
2. PM 관점: 제품 완성도와 로드맵
3. 개발팀 관점: 기술적 부채와 리소스
4. 고객 관점: 가치와 사용성

각 관점의 결론을 종합해서 최종 권고안을 제시해줘."
```

---

#### 메타인지적 프롬프팅 (Metacognitive Prompting)

**정의**: AI의 **사고 과정을 명시적으로 요청**

**예시**:
```
"이 문제를 해결하기 전에:

1. 문제를 정확히 이해했는지 다시 정리해줘
2. 해결에 필요한 정보가 무엇인지 나열해줘
3. 가능한 접근 방법들을 비교해줘
4. 선택한 방법의 장단점을 설명해줘
5. 그 다음 해결책을 제시해줘"
```

**Chain-of-Thought (CoT)** 변형:
```
"단계별로 생각해줘 (Let's think step by step)"
```

---

### 프롬프트 엔지니어링의 한계와 고려사항

**1. 프롬프트만으로 해결 불가능한 문제**
```
- 학습되지 않은 지식 (지식 컷오프)
- 복잡한 수학/논리 연산
- 실시간 정보 필요
- 100% 정확성 보장
```

**2. 프롬프트 취약점**
```
- 프롬프트 주입 (Prompt Injection)
- 탈옥 시도 (Jailbreaking)
- 민감 정보 노출 위험
→ 보안 레이어 필요
```

**3. 일관성 문제**
```
- 같은 프롬프트도 다른 결과 가능
- Temperature, 모델 버전에 따라 변동
→ 테스트 및 평가 체계 필요
```

**4. 비용 고려**
```
- 긴 프롬프트 = 높은 토큰 비용
- 체이닝 = 여러 번 호출
→ 프롬프트 최적화 필요
```

**베스트 프랙티스**:
- 명확하고 구체적으로 작성
- Few-shot 예시 활용
- 지속적인 테스트와 개선
- 사용 사례에 맞는 기법 선택




## 과제

### 연구 과제
1. LLM을 활용한 서비스의 기능을 하나 선택하고 살펴봅니다. "다음 토큰을 확률적으로 선택한다"는 원리가, 해당 기능이 제공하는 제품 경험과 어떻게 연결되는지 설명해 보십시오.
2. 강의에서 배운 LLM의 한계(환각, 지식 컷오프, 출처 추적 불가, 맞춤형 지식 부재) 중, 위의 기능에서 가장 문제가 될 수 있는 것은 무엇입니까? 그리고 그 문제가 실제로 발생하면 고객 경험에 어떤 영향을 미칩니까?
3. 실제 서비스에 AI 생성 기능을 추가한다고 할 때, 위 한계들 중 어떤 것이 가장 치명적일지 예상하고, 강의에서 배운 해결책(RAG, 프롬프트 엔지니어링, 하이브리드 접근법) 중 어떤 것을 적용할 수 있을지 검토해 봅니다.

### 실전 과제
1. 제품을 하나 선택해 생성형 AI를 결합하여 콘텐츠를 생성해내는 데 적합한 기능을 탐색하고 선정합니다.
2. 선정한 기능의 고객 가치를 극대화하기 위해 어떤 콘텐츠가 생성되어야 하는지 구체적으로 정리합니다.
3. 해당 콘텐츠를 효과적으로 생성하기 위해 필요한 프롬프트를 전략적으로 설계합니다.
4. (옵션) 설계한 프롬프트를 활용해 실제로 콘텐츠를 생성해보고, 생성된 결과물이 목표한 목적과 기대에 부합하는지 검토하고 개선점을 도출합니다.


## 참고 자료
- [3강 연구 과제 PDF](/assets/pdf/goormti3iw.pdf)
- [3강 실전 과제 PDF](/assets/pdf/goormti3gw.pdf)

### 학습 자료 및 출처

#### 서적

- **"Attention Is All You Need"** - Vaswani et al. (2017)
  https://arxiv.org/abs/1706.03762
  Transformer 아키텍처의 원본 논문, 자기 주의 메커니즘의 기초

- **"Language Models are Few-Shot Learners" (GPT-3 Paper)** - Brown et al. (2020)
  https://arxiv.org/abs/2005.14165
  대규모 언어 모델의 능력과 프롬프트 엔지니어링 기초

- **"Denoising Diffusion Probabilistic Models"** - Ho et al. (2020)
  https://arxiv.org/abs/2006.11239
  확산 모델의 핵심 원리

- **"High-Resolution Image Synthesis with Latent Diffusion Models"** - Rombach et al. (2022)
  https://arxiv.org/abs/2112.10752
  Stable Diffusion의 기반 논문

- **"Retrieval-Augmented Generation for Knowledge-Intensive NLP Tasks"** - Lewis et al. (2020)
  https://arxiv.org/abs/2005.11401
  RAG 기법의 원본 논문

#### 관련 강의 및 코스

- **Anthropic Prompt Engineering Guide**
  https://docs.anthropic.com/claude/docs/prompt-engineering
  프롬프트 엔지니어링 공식 가이드

- **OpenAI Prompt Engineering Guide**
  https://platform.openai.com/docs/guides/prompt-engineering
  GPT 모델을 위한 프롬프트 설계 가이드

- **DeepLearning.AI - ChatGPT Prompt Engineering for Developers**
  https://www.deeplearning.ai/short-courses/chatgpt-prompt-engineering-for-developers/
  Andrew Ng의 프롬프트 엔지니어링 무료 강좌

- **Stanford CS324 - Large Language Models**
  https://stanford-cs324.github.io/winter2022/
  LLM에 대한 체계적인 학술 강의

- **Hugging Face NLP Course**
  https://huggingface.co/course
  Transformer 및 NLP 실습 과정

#### 실무 사례 참고

- **OpenAI Blog**
  https://openai.com/blog
  GPT, DALL-E 등 모델 발표 및 활용 사례

- **Anthropic Research**
  https://www.anthropic.com/research
  Claude 모델 및 AI 안전성 연구

- **Google AI Blog**
  https://ai.googleblog.com/
  Gemini, PaLM 등 구글 AI 연구

- **Stability AI Blog**
  https://stability.ai/blog
  Stable Diffusion 업데이트 및 활용 사례

- **Hugging Face Blog**
  https://huggingface.co/blog
  오픈소스 AI 모델 및 활용 사례

- **LangChain Blog**
  https://blog.langchain.dev/
  RAG 및 LLM 애플리케이션 구축 사례

#### YouTube

- **Andrej Karpathy**
  https://www.youtube.com/@AndrejKarpathy
  GPT, Transformer 등 딥러닝 개념 설명 (전 OpenAI/Tesla)

- **3Blue1Brown**
  https://www.youtube.com/@3blue1brown
  신경망, Attention 메커니즘 시각화 설명

- **Yannic Kilcher**
  https://www.youtube.com/@YannicKilcher
  AI 논문 리뷰 및 해설

- **Two Minute Papers**
  https://www.youtube.com/@TwoMinutePapers
  최신 AI 연구 요약

- **AI Explained**
  https://www.youtube.com/@aiaborr
  LLM 및 생성형 AI 최신 동향 분석

- **Matt Wolfe**
  https://www.youtube.com/@maborr
  AI 도구 리뷰 및 활용법

#### 커뮤니티

- **r/MachineLearning (Reddit)**
  https://www.reddit.com/r/MachineLearning/
  ML/AI 연구 및 논의

- **r/LocalLLaMA (Reddit)**
  https://www.reddit.com/r/LocalLLaMA/
  오픈소스 LLM 커뮤니티

- **Hugging Face Discord**
  https://huggingface.co/join/discord
  오픈소스 AI 모델 커뮤니티

- **LangChain Discord**
  https://discord.gg/langchain
  LLM 애플리케이션 개발 커뮤니티

- **Midjourney Discord**
  https://discord.gg/midjourney
  이미지 생성 AI 커뮤니티

- **Stable Diffusion Discord**
  https://discord.gg/stablediffusion
  오픈소스 이미지 생성 커뮤니티

#### 도구 및 프로토타이핑

- **ChatGPT / Claude / Gemini**
  https://chat.openai.com / https://claude.ai / https://gemini.google.com
  텍스트 생성 AI 대표 서비스

- **DALL-E / Midjourney / Stable Diffusion**
  https://openai.com/dall-e / https://midjourney.com / https://stability.ai
  이미지 생성 AI 대표 서비스

- **Hugging Face**
  https://huggingface.co/
  오픈소스 AI 모델 허브 및 실행 환경

- **LangChain**
  https://langchain.com/
  LLM 애플리케이션 개발 프레임워크

- **Pinecone / Chroma / Weaviate**
  https://pinecone.io / https://trychroma.com / https://weaviate.io
  RAG를 위한 벡터 데이터베이스

- **OpenAI Playground**
  https://platform.openai.com/playground
  GPT 모델 프롬프트 테스트 환경

- **Anthropic Claude API Console**
  https://console.anthropic.com/
  Claude 모델 프롬프트 테스트 환경

- **Prompt Engineering Guide (DAIR.AI)**
  https://www.promptingguide.ai/
  프롬프트 엔지니어링 종합 가이드

- **Perplexity AI**
  https://perplexity.ai/
  RAG 기반 검색 엔진 (출처 명시)

- **Replicate**
  https://replicate.com/
  오픈소스 AI 모델 API 서비스